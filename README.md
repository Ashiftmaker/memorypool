# 内存池设计思路

## 总体思路：
内存池管理多个内存块，每一个内存块管理多个可变内存结点，内存池里管理一个内存块单链表，每一个内存块里面管理一个内存节点双向链表（用双链表方便节点合并）。
申请和销毁的内存是整个连续大块内存中截取的小块内存节点，这里肯定会涉及到内存分割，可以用char*类型表示地址，保证计算时候每次移动都是一个字节为单位，但是这有被用作指向char类型的指针的可能，可能意外改变内容，内存大小是以byte为单位的，每次移动方便而且它禁用了&*等运算符，所以选择Byte*指向内存
内存每次申请新的内存节点都要在堆里创建一个BlockNode来存储节点信息，这需要频繁的系统调用，也容易产生碎片，这与内存池的初衷是不符的，可以在创建内存池的时候向系统申请一块连续的内存作为节点池，用链表存储指定个内存结点，每次取用和释放节点都从节点池里面取用，这样可以只进行一次系统调用就解决了频繁创建和销毁内存块节点的需求

## 文件结构：
|————memorypool.h   内存池，管理内存块单链表和内存块节点池，可以申请，释放和打印详情
|————memorypool.cpp
|
|————memoryblock.h  内存块，包含内存块节点双链表，申请，释放节点
|————memoryblock.cpp
|
|————blocknodepool.h  内存块节点池，有一个内存块节点单链表，可以从里面取用和归还内存块（目的是每次创建和销毁节点的收不用系统调用）
|————blocknodepool.cpp
|
|————blocknode.h 内存块节点类，包含节点的起终地址和前后节点等信息
|
|————main.cpp 测试文件

## 功能设计
### 创建内存池
初始化的时候内存池初始化一个指定大小的内存块(内存块申请空间)，这个内存块的所有空间作为一整个节点，标记为未使用，申请一块内存并初始化为内存块节点池，以后取用块内节点就从里面取放；

### 申请内存
传入需要内存的大小，内存池判断这个内存的大小是否超过指定块的大小，如果超过了就直接创建前一个新块（大小为所需内存大小，这个块一个节点），插入到内存块链表里面让内存池管理即可；如果不超过内存块大小就现在内存块链表里面遍历找到一个大于这个所需内存的节点，切割出需要的内存大小作为新节点，并且将切割剩余部分作为另一个节点，将这两个节点插入节点链表；

### 释放内存
先遍历块再遍历节点找到起始地址与要销毁的地址相同的节点，把这个节点标记为未使用，然后检查这个节点的前驱节点和后继节点是不是未使用的（双向链表的好处就是好找前驱节点的后继节点），要是是的话就合并为一个节点放在节点链表中；

### 检查泄露
在内存池的析构函数中遍历所有节点看有没有是标记为used的

## 类的设计
### BlockNode
BlockNode类存储可变内存节点信息，核心是表示一个内存节点在内存块里的位置以及这个内存块是否被使用；

### MemoryBlock
MemoryBlock表示内存块，m_realAdress是申请的指定块大小的整块内存（m_blockSize），还要包括一个类节点的链表的头节点（构造块的时候将整块作为一个节点并且标记为未使用），以及一个指向下一个内存块的节点的指针用来构建内存块之间的联系

### MemoryPoll
MemoryPOll表示一个内存池，内存池大小，指定内存块大小是必要的，以及要包含一个内存块链表的头节点
